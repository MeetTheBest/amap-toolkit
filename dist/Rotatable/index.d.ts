import { default as RotationOptions } from './type';
import { default as Event } from '../Event';
import { default as LikeRectangle } from '../LikeRectangle';
import { default as ElementRotator } from 'element-rotator';

declare class Rotatable extends Event {
    likeRectangleIns: LikeRectangle & AMap.Polygon;
    opts: RotationOptions;
    elementRotatorIns: ElementRotator | null;
    rotationPointIns: AMap.Marker | null;
    midPoint: AMap.LngLat;
    initAngle: number;
    offset: number;
    rotationLine: AMap.Polyline;
    customRotationDOMId: string;
    moveableElementId: string;
    targetElementId: string;
    constructor(likeRectangle: LikeRectangle & AMap.Polygon, opts?: RotationOptions);
    get mapIns(): {
        _outseaDataType: string;
        setCenter(center: AMap.LngLat | [number, number], immediately?: boolean | undefined, duration?: number | undefined): void;
        getStyleByUserId(id: any, zoom: number): any;
        getCustomTypeByContainerPos(lnglat: any): any;
        getScreenShot(width: number, height: number): string;
        updateView(view: any, render?: boolean | undefined): void;
        destroy(): void;
        setZoomAndCenter(zoom: number, center: AMap.LngLat | [number, number], immediately?: boolean | undefined, duration?: number | undefined): void;
        getBounds(): AMap.Bounds;
        getCenter(): AMap.LngLat;
        getGraphicInfo(): {
            hardwareAccEnabled: any;
        };
        setZoom(zoom: number, immediately?: boolean | undefined, duration?: number | undefined): void;
        getZoom(digits?: number | undefined): number;
        zoomIn(): void;
        zoomOut(): void;
        getPitch(): number;
        setPitch(pitch: number, immediately?: boolean | undefined, duration?: number | undefined): void;
        getRotation(): number;
        setRotation(rotation?: number | undefined, immediately?: boolean | undefined, duration?: number | undefined): void;
        setBounds(bounds: number[] | AMap.Bounds, immediately?: boolean | undefined, avoid?: number[] | undefined): void;
        panTo(lnglat: AMap.LngLat | [number, number], duration?: number | undefined): void;
        panBy(x: number, y: number, duration?: number | undefined): void;
        getContainer(): HTMLDivElement;
        add(features: {
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        } | {
            CLASS_NAME: string;
            _zIndex: number;
            _opts: any;
            setMap(map: any | null): void;
            setzIndex(z: number): void;
            setOpacity(opacity: number): void;
            getOpacity(): number;
            getzIndex(): number;
            getOptions(): any;
            getZooms(): [number, number];
            setZooms(zooms: [number, number]): void;
            getVisible(): boolean;
            show(): void;
            hide(): void;
            destroy(): void;
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        } | ({
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        } | {
            CLASS_NAME: string;
            _zIndex: number;
            _opts: any;
            setMap(map: any | null): void;
            setzIndex(z: number): void;
            setOpacity(opacity: number): void;
            getOpacity(): number;
            getzIndex(): number;
            getOptions(): any;
            getZooms(): [number, number];
            setZooms(zooms: [number, number]): void;
            getVisible(): boolean;
            show(): void;
            hide(): void;
            destroy(): void;
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        })[]): void;
        remove(features: {
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        } | {
            CLASS_NAME: string;
            _zIndex: number;
            _opts: any;
            setMap(map: any | null): void;
            setzIndex(z: number): void;
            setOpacity(opacity: number): void;
            getOpacity(): number;
            getzIndex(): number;
            getOptions(): any;
            getZooms(): [number, number];
            setZooms(zooms: [number, number]): void;
            getVisible(): boolean;
            show(): void;
            hide(): void;
            destroy(): void;
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        } | ({
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        } | {
            CLASS_NAME: string;
            _zIndex: number;
            _opts: any;
            setMap(map: any | null): void;
            setzIndex(z: number): void;
            setOpacity(opacity: number): void;
            getOpacity(): number;
            getzIndex(): number;
            getOptions(): any;
            getZooms(): [number, number];
            setZooms(zooms: [number, number]): void;
            getVisible(): boolean;
            show(): void;
            hide(): void;
            destroy(): void;
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        })[]): void;
        lngLatToCoords(lnglat: AMap.LngLat | [number, number]): [number, number];
        coordsToLngLat(coords: [number, number]): AMap.LngLat;
        lngLatToContainer(lnglat: AMap.LngLat | number[]): AMap.Pixel;
        containerToLngLat(pixel: number[] | AMap.Pixel): AMap.LngLat;
        coordToContainer(coord: [number, number]): [number, number];
        containerToCoord(pixel: number[] | AMap.Pixel): number[];
        pixelToLngLat(pixel: number[] | AMap.Pixel, z?: number | undefined): AMap.LngLat;
        lngLatToPixel(lnglat: AMap.LngLat | number[], z?: number | undefined): AMap.Pixel;
        getResolution(point?: AMap.LngLat | undefined): number;
        getScale(dpi: number): number;
        getCity(cbk: (result: any) => void, lnglat: number[]): void;
        setCity(cityName: string, cbk: (center: number[] | null, zoom: number | null) => void): void;
        setFitView(overlays?: {
            has(vector: any): boolean;
            clear(): void;
            setOptions(opt: any): void;
            query(lnglat: AMap.LngLatLike): {
                _needUpdate: boolean;
                readonly CLASS_NAME: "Overlay" | "Overlay.Polygon" | "Overlay.CorePolygon" | "Overlay.CorePolyline" | "Overlay.Rectangle" | "Overlay.Ellipse" | "Overlay.Circle" | "Overlay.CircleMarker" | "Overlay.Polyline" | "Overlay.BezierCurve" | "Overlay.OverlayGroup" | "Overlay.GeoJSON";
                className: "Overlay" | "Overlay.Polygon" | "Overlay.CorePolygon" | "Overlay.CorePolyline" | "Overlay.Rectangle" | "Overlay.Ellipse" | "Overlay.Circle" | "Overlay.CircleMarker" | "Overlay.Polyline" | "Overlay.BezierCurve" | "Overlay.OverlayGroup" | "Overlay.GeoJSON";
                _isMoveing: boolean;
                visible: boolean;
                setMap(map: any | null): void;
                getMap(): any | null;
                contains(...args: any[]): boolean;
                remove(): void;
                hide(): void;
                show(): void;
                setDraggable(draggable: boolean): boolean;
                setOptions(args?: any): void;
                getOptions(): any;
                getExtData(): any;
                setExtData(extData: any): void;
                getCursor(): any;
                emit(type: string, events?: any): any;
                getDraggable(): boolean;
                on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
                off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
                hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
                clearEvents(type: AMap.EventType): any;
                getEvents(): Record<string, any[]>;
            } | undefined;
            getBounds(): AMap.Bounds | undefined;
        } | {
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        }[] | undefined, immediately?: boolean | undefined, avoid?: number[] | undefined, maxZoom?: number | undefined): AMap.Bounds | undefined;
        getFitZoomAndCenterByOverlays(overlayList: any[], avoid?: number[] | undefined, maxZoom?: number | undefined): any[] | undefined;
        getFitZoomAndCenterByBounds(bounds: number[] | AMap.Bounds, avoid?: number[] | undefined, maxZoom?: number | undefined): any[];
        addControl(control: AMap.Control): void;
        removeControl(control: AMap.Control): void;
        setMapStyle(value: string): void;
        getMapStyle(): string;
        getAllOverlays(type?: string | undefined): any[];
        clearMap(): void;
        clearInfoWindow(): void;
        getFeatures(): string | string[] | undefined;
        setFeatures(features: string[]): void;
        getMapApprovalNumber(): any;
        setMask(maskPath: number[][]): void;
        setLabelRejectMask(reject: boolean): void;
        className: string;
        _resource: Resource<Iterable<{
            destroy?: (() => void) | undefined;
        }> & {
            taskManger: TaskManager;
            SDFCombineTexture: SDFCombineTexture;
            taskThread: RenderThread;
            drawMode: string;
            taskQueue: TaskQueue;
            oversea: Oversea;
            highlight: Highlight;
        }>;
        _loadData?: string | undefined;
        gl?: WebGLRenderingContext | undefined;
        canvas?: HTMLCanvasElement | undefined;
        WebGLParams: any;
        _sourceManager: SourceManager;
        getGL(): WebGLRenderingContext | undefined;
        loadData(): string | undefined;
        getGraphic(): {
            hardwareAccEnabled: any;
        };
        getSize(): AMap.Size;
        addLayer(layer: {
            CLASS_NAME: string;
            _zIndex: number;
            _opts: any;
            setMap(map: any | null): void;
            setzIndex(z: number): void;
            setOpacity(opacity: number): void;
            getOpacity(): number;
            getzIndex(): number;
            getOptions(): any;
            getZooms(): [number, number];
            setZooms(zooms: [number, number]): void;
            getVisible(): boolean;
            show(): void;
            hide(): void;
            destroy(): void;
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        }): void;
        removeLayer(layer: {
            CLASS_NAME: string;
            _zIndex: number;
            _opts: any;
            setMap(map: any | null): void;
            setzIndex(z: number): void;
            setOpacity(opacity: number): void;
            getOpacity(): number;
            getzIndex(): number;
            getOptions(): any;
            getZooms(): [number, number];
            setZooms(zooms: [number, number]): void;
            getVisible(): boolean;
            show(): void;
            hide(): void;
            destroy(): void;
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        }): void;
        setLayers(layers: {
            CLASS_NAME: string;
            _zIndex: number;
            _opts: any;
            setMap(map: any | null): void;
            setzIndex(z: number): void;
            setOpacity(opacity: number): void;
            getOpacity(): number;
            getzIndex(): number;
            getOptions(): any;
            getZooms(): [number, number];
            setZooms(zooms: [number, number]): void;
            getVisible(): boolean;
            show(): void;
            hide(): void;
            destroy(): void;
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        }[]): void;
        getLayers(): {
            CLASS_NAME: string;
            _zIndex: number;
            _opts: any;
            setMap(map: any | null): void;
            setzIndex(z: number): void;
            setOpacity(opacity: number): void;
            getOpacity(): number;
            getzIndex(): number;
            getOptions(): any;
            getZooms(): [number, number];
            setZooms(zooms: [number, number]): void;
            getVisible(): boolean;
            show(): void;
            hide(): void;
            destroy(): void;
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        }[];
        getLayersDangerous(): {
            CLASS_NAME: string;
            _zIndex: number;
            _opts: any;
            setMap(map: any | null): void;
            setzIndex(z: number): void;
            setOpacity(opacity: number): void;
            getOpacity(): number;
            getzIndex(): number;
            getOptions(): any;
            getZooms(): [number, number];
            setZooms(zooms: [number, number]): void;
            getVisible(): boolean;
            show(): void;
            hide(): void;
            destroy(): void;
            on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
            off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
            hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
            clearEvents(type: AMap.EventType): any;
            emit(type: AMap.EventType, data?: any): any;
            getEvents(): Record<string, any[]>;
        }[];
        getStatus(): {
            dragEnable: boolean;
            zoomEnable: boolean;
            doubleClickZoom: boolean;
            keyboardEnable: boolean;
            jogEnable: boolean;
            scrollWheel: boolean;
            zoomSpeed: number;
            animateEnable: boolean;
            touchZoomCenter: number;
            touchZoom: boolean;
            pitchEnable: boolean;
            rotateEnable: boolean;
            showBuildingBlock: boolean | undefined;
            isHotspot: boolean;
            mapstyleUrl: string;
            features: string | string[] | undefined;
            allBubble: boolean;
            pickWhenMoving: boolean;
        };
        setStatus(status: any): void;
        getOutseaState(): boolean;
        getOutseaDataType(): string;
        getMapboxStyle(): any;
        _setStyleByPlat(style: any): void;
        getDefaultCursor(): string;
        setDefaultCursor(cursor: string): void;
        getLimitBounds(): AMap.Bounds | undefined;
        setLimitBounds(bounds: number[] | AMap.Bounds): void;
        clearLimitBounds(): void;
        getZooms(): [number, number];
        setZooms(zooms: [number, number]): void;
        getSkyColor(optimalZoom: number): number[];
        getatmosColor(optimalZoom: number): number[];
        getStamp(): number;
        getStyleByIdForUser(id: any, zoom: number): any;
        getTileZoom(z: number): any;
        getCustomTypeByPos(pos: any): any;
        getLabelRejectMask(): boolean;
        setHighlight(mainKey: number, subKey: number[]): void;
        start(): void;
        stop(): void;
        on(type: AMap.EventType | AMap.EventType[], fn: (e: any) => void, context?: any, once?: boolean | undefined): any;
        off(type: AMap.EventType, fn: (e: any) => void, context?: any): any;
        hasEvents(type: AMap.EventType, fn: (e: any) => void, context?: any): boolean;
        clearEvents(type: AMap.EventType): any;
        emit(type: AMap.EventType, data?: any): any;
        getEvents(): Record<string, any[]>;
    };
    get center(): AMap.Vector2;
    get rotatable(): boolean | undefined;
    get draggable(): any;
    get radius(): number;
    open(): void;
    reset(): void;
    close(): void;
    registryLikeRectangleEvents(): void;
    destroyLikeRectangleEvents(): void;
    /**
     * 旋转点（即中心点）
     */
    createRotationPoint(): Promise<void>;
    genMarkerContent: () => string;
    setMarkerRotatable: () => void;
    registryEvent(): void;
    destroyEvent(): void;
    onRotateStart: () => void;
    onRotate: (data: any) => void;
    onRotateEnd: () => void;
    rotate: (deg: number) => void;
    calcRotatePoint: (point: AMap.Pixel, center: AMap.Pixel, angle: number) => {
        x: number;
        y: number;
    };
    getDOMTransformRotate: (dom: HTMLElement) => number;
    calcMidPoint(): AMap.LngLat;
    /**
     * 计算第一条连线的中点，位于中心点角度
     */
    calcInitAngle(): number | undefined;
    calcInitOffset(): number;
    updateRotationAbleOffset: () => void;
    private onDragStart;
    /**
     * 拖拽结束后，需要重新计算一下点位数据
     */
    private onDragEnd;
    setRotationLine(): void;
}
export default Rotatable;
